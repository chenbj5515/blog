书接上文，我们了解了React调度的核心scheduler，但是关于React的调度我们还有很多疑惑：
1. React中任务调度的任务到底是什么
2. React是如何调用scheduler这个包的
3. lane模型和scheduler有一些类似的功能比如避免饥饿问题还有**表示不同优先级**。但为什么有了scheduler还不够呢？lane模型到底有哪些额外的能力？

## 初识React中的任务

### 任务是哪来的？
讨论任务是什么之前我们必须先讨论清楚任务是从哪里来的。

实际上，最典型的任务是开发者调用通过useState获取到的setState方法发起的更新任务。

而直接setState是一个同步优先级的任务，我们先单步调试最简单的同步更新这一个操作梳理下基本流程，打好基础。

### 任务的实体

我们上面已经认识到任务其实主要指的是setState方法发起的更新任务，那么很自然地想到，任务在React源码中应该有一个实体吧，那么实体到底是怎样的呢？

实际上，任务是在setState的内部实现也就是dispatchSetState方法中生产的。

它被命名为update：

```
var update = {
    // 此时lane为1，代表同步更新的优先级(直接调用setCounter是同步的更新)
    lane: lane,
    // counter状态本次动作要被修改为的值，也就是1
    action: action,
    // 马上会被置为true
    hasEagerState: false,
    // 最新状态，也就是1
    eagerState: null,
    // 马上会被置为自身，这个对今天的主题来说应该是不重要的
    next: null
};
```

是不是看起来过于简单了，值得关注的只有表示优先级的lane和最新状态eagerState两个。

实际上任务本身很简单，复杂的是如何任务是如何调度并消费的。

## 同步任务从生产到消费的全流程

我把调用栈的关键节点列在下方，你可以在react-dom.development.js中打debugger后点击右侧按钮后单步调试并验证这个流程：

1. update是在dispatchSetState中生产的，上面主要是记录了最新的状态值
2. 在enqueueUpdate$1中update被设置为queue的pending属性，而queue是组件fiber上的一个属性
3. ensureRootIsScheduled这里开始任务的schedule
4. 因为是同步任务，所以由scheduleSyncCallback把performSyncWorkOnRoot这个callback压入syncQueue
5. 注意上面的压入队列仅仅是React内部压入队列，这样永远都不会被执行。真正想执行要发起浏览器的任务，这个活是scheduleMicrotask函数负责的。
它把读取syncQueue中callback并执行这个动作压入了微任务队列，这样callback就可以很快被执行了
6. callback就是performSyncWorkOnRoot，这里会进入workLoopSync，while循环执行performUnitOfWork(workInProgress)直到workInProgress为null
7. 上面的方法继续执行会进入beginWork，从root fiber开始遍历，不过由于没有要更新的东西，所以都会bailout——也就相当于啥也不敢直接继续遍历
8. 直到到达更新发生的组件fiber，遍历停止，通过updateFunctionComponent方法进行更新
9. 进入renderWithHooks中会重新执行组件函数，重新执行里面的useState等hooks，走到updateReduce
10. updateReducer，注意这里才是消费update的地方，这里简单来说就是返回1中传入的最新值给函数组件
11. 函数体中其他代码执行完毕后，会回到performSyncWorkOnRoot作用域，执行commitRoot完成DOM更新工作

回顾这个流程，其实是有很多需要细说的点。

### 如何从root fiber上识别到有同步任务的？
dispatchSetState是任务的源头，生产了一个同步优先级的update并挂在到了fiber上。

这里的fiber肯定是组件的fiber，但是到了第3步时，确实从根fiber上识别到有同步任务，这个同步任务是怎么被识别到的呢？

其实上***在dispatchSetState中会在生成完update后，组件fiber就有了一个lanes属性***，同步任务对应的值为1，这个lanes会被不断地被向上合并到父级fiber的childLanes属性上。

这意味着最终这个lanes会让root fiber的childLanes和pendingLanes属性为1。

最终在ensureRootIsScheduled中会通过getNextLanes方法取出最右边的lanes位，也就是最高优先级的任务，一看是1也就是同步任务。

所以就会选择调用scheduleSyncCallback方法来schedule任务。

### 同步优先级的更新从宏观上看是异步的？
第5点中提到了，同步优先级的任务是通过压入浏览器的微任务队列来真正发起任务的，所以确实是异步的。

我在setCounter后log了“紧随setCounter后的代码”，你可以看到这段先打印，然后才函数组件重新执行并打印rerender。

所以那为什么还叫同步优先级呢？其实这里的同步是指performUnitOfWork过程。

如果是同步优先级，这里就不会判断任务的执行时间并yield，而是会同步执行完while循环。所谓的同步是指这部分代码的执行是同步的，而整体来看，还是异步的。

### 为什么不能直接update更新发生的组件fiber？
第7步提到了会从root fiber开始遍历，bailout掉前面的fiber，直到更新发生的组件fiber。

其实仅考虑当前例子这种最简单的情况，也就是整个fiber树上只有一个地方有更新的话，的确是从组件fiber更新合理。

但实际上其他地方有可能有低优任务还没更新，并且可能已经过期急需更新，所以不能从组件fiber这开始遍历。

### bailout和update两种行为的判定条件是什么？

主要是通过checkScheduledUpdateOrContext方法检查current fiber上的lanes是不是包括subtreeRenderLanes。

subtreeRenderLanes一开始就在performSyncWorkOnRoot->renderRootSync->prepareFreshStack这里被设置为1——也就是当前任务的lanes。

其他的fiber上lanes都是0，所以不包括，所以会被bailout掉。

而到了setCounter所在组件的fiber，其lanes是1包括subtreeRenderLanes，所以就会走到update。

## 通过scheduler包来调度低优任务

通过同步任务来跑了一遍流程，我们大致了解了最简单的更新是什么样的。

然而同步任务流程中并没有涉及scheduler这个包。

那么我们接下来探究下低优任务，看看React是如何与scheduler配合进行低优任务的调度的。

### 什么是低优任务？

直接setCounter是一个同步优先级的任务，而用startTransition包裹的setState就是较低的transition优先级的任务。

```
const [isPending, startTransition] = useTransition();
// 这次的更新任务就是较低优先级的任务
startTransition(() => {
    setCounter(counter + 1)
})
```

### 低优任务与同步任务的流程差异
实际上，通过上面探究最简单的同步更新流程，和对scheduler的学习，已经可以猜想会有这些差异：
1. 第1步中的update对象的优先级肯定是transition优先级对应的lane也就是
2. 第4步肯定就不是由scheduleSyncCallback处理了
3. 第6步中不会同步执行while循环处理完所有的fiber，而是会5ms中断一次让出线程，直到完成或者超时。（超时就同步执行完）

#### 整个过程不止一个update

首先在dispatchSetState这里打断点验证第一点，点击后发现优先级还是1。

这是一个重要的点，因为调用startTransition包裹会先把isPending状态置为true，然后置为false，然后再执行callback也就是setCounter。

所以其实需要注意，我们这个例子中一次点击会有三个更新。

所以其实整个过程分为setPending过程，这里会两次修改isPending。然后才是开发者callback中的setCounter过程。

两个过程我们逐个研究。

#### setPending过程

1. setPending是在startTransition这里的。

2. isPending这个值在useTransition初次调用时会返回false。

3. 在调用startTransition时首先会调用setPending设置为true。我们的断点就打在这里。

4. **setPending(true)**，是一个同步的更新，但是我们前面已经得出了结论，同步仅仅是后面perform的时候同步，整个setPending过程是异步的。
   所以这里应该是把任务压入了syncQueue中，然后压入微任务队列，等待执行。
   为了验证这一点，我到控制台的Scope区域中的Local作用域，也就是react-dom的全局域中找到syncQueue变量，看到确实有且只有这个任务。

5. 所以setPending这个任务挂起了，继续执行startTransition中剩余任务。

6. ReactCurrentBatchConfig$2.transition = 1; 通过这句全局标记为进入了transition状态。

7. **setPending(false)**，在置为true的任务还没执行的同时执行这个。很有趣，我们看看接下来会如何。

8. 因为全局进入了transition状态，所以这个置为true的更新的lanes的优先级为64也就是transition优先级对应的值。

9. 在这个任务被schedule的地方ensureRootIsScheduled中，我发现这个低优任务并没有像前面的任务一样被schedule而是直接return了。
   这里判断return的逻辑是root.callbackPriority和当前root上最高优的任务比较，相等则return。
   而callbackPriority是上次schedule那个同步优先级任务后设置的，上次是同步任务为1嘛，这次root最高优的还是1，所以return掉了。
   这里解读一下React的意图，应该是**如果当前最高优的任务的优先级和正在被schedule的任务的优先级是一样的，那就不再schedule新的任务，而是等待当前任务执行后再说。**
   但是你直接这次直接return了可以，那么这次设置为false的更新是什么时候处理的呢？我们带着疑问继续看。

10. 没有被schedule但是后面进入了entangleTransitionUpdate逻辑，把root上entanglements数组的第6项置为了64。

11. 回到了startTransition方法，提醒下，这时isPeding设置为true的更新在队列中等待执行，而置为false的更新被直接return掉了。
    因为startTransition方法中还有同步代码没有执行完，所以置为true的更新还要等会才能执行。

12. 同步的代码首先还有callback函数也就是开发者传给startTransition的callback，也就是setCounter方法。
    这个的更新流程和置为false是一样的。

13. 同步的代码执行完毕，在微任务队列中的flushSyncCallbacks会被执行。
    （P.S. 这里有一个不重要的小细节，就是flushSyncCallbacks其实不是作为微任务被浏览器执行的，而是React的事件系统触发的。触发位置是flushSyncCallbacksOnlyInLegacyMode函数。）
    执行同步的perform操作，这个操作和第一章的同步操作一致，这里重复强调一次。
    首先在两次setPending的时候会把Demo Fiber上的memoizedState（这个变量其实叫hooksList更好）链表上useTransition hook对应的对象上的memoizedState状态修改为true。
    注意，虽然setPending(false)是后执行的，但是非同步的更新不会直接修改memoizedState而是会把这个更新放置于baseQueue也就是队列中等待着。
    这样重新执行组件函数时，useTransition hook会返回给函数体fiber上memoizedState的值，于是后续就会更新DOM，我们就能在页面上看到isPending值更新为true。
    这也就标志着进入了transition状态。

14. 同步更新圆满结束，但还有两个transition优先级的更新还没进行。这里我猜想会在同步更新结束后再调用shedule方法处理低优更新。

15. 果然，看到在performSyncWorkOnRoot中，执行commit完成所有DOM更新之后，又调用了ensureRootIsScheduled开启剩余任务的调度。

16. 再次来到这里后，我们还有两个64优先级的任务，一个是isPending置为false，一个是counter置为1。
    这两个同优先级的任务应该是会被一次处理掉，整个过程确实会用scheduler的包schedule任务，并且确实执行workLoop时也是走的可切片版本。

17. transition优先级的update与同步优先级的update不同之处在于transition的update上hasEagerState被标记为false，也就是没有紧急的状态更新的意思。
    所以在最后消费时不会把返回给组件函数的newState赋值为低优更新的值。

更新其实分为生产和消费两端。生产端在dispatchSetState中生成update实体，消费端在useState等hook函数内部根据update返回值给函数体。

但是









